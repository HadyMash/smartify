/* eslint-disable @typescript-eslint/no-unused-vars */
import {
  MFAError,
  MFACode,
  MFA,
  MFAErrorType,
  IncorrectPasswordError,
  srpSessionSchema,
  SRPSession,
} from '../../schemas/auth/auth';
import {
  Email,
  InvalidUserError,
  InvalidUserType,
  LoginData,
  RegisterData,
  UserWithId,
  userWithIdSchema,
} from '../../schemas/auth/user';
import { ObjectIdOrString } from '../../schemas/obj-id';
import { bigIntModPow } from '../../util';
import { DatabaseService } from '../db/db';
import { MFAService } from './mfa';
import crypto, { createHash, Hash } from 'crypto';

export class AuthService {
  protected readonly db: DatabaseService;

  constructor() {
    this.db = new DatabaseService();
  }

  /**
   * Register the user with the system and initiate their authentication
   * information
   * @param data - The user's data
   * @param salt - The user's randomly generated salt
   * @param verifier - The verifier generated from the user's password by the
   * client
   * @returns The user's id and their MFA formatted key
   * @throws InvalidUserError if the user already exists
   */
  public async initUserSRP(data: RegisterData) {
    // check user doesn't already exists
    const userExists = await this.db.userRepository.userExistsEmail(data.email);
    if (userExists) {
      throw new InvalidUserError({ type: InvalidUserType.ALREADY_EXISTS });
    }

    const ms = new MFAService();
    const formattedKey = ms.generateMFAFormattedKey();
    const userId = await this.db.userRepository.createUser(data, formattedKey);

    return { userId, formattedKey };
  }

  //public async getUserAuth(email: Email) {
  //}

  /**
   * Initialises an SRP auth session for the user
   * @param email - The user's email
   * @returns The user's session id, salt, and the public key generated by the
   * server (B)
   * @throws An error if the user does not exist
   * @throws An error if the serer failed to create the session
   */
  public async initAuthSession(email: Email): Promise<{
    salt: string;
    B: bigint;
  }> {
    console.log('generating server keys');

    const { b, B } = SRP.generateServerKeys();

    const { salt, verifier } =
      await this.db.userRepository.getUserSRPCredentials(email);
    console.log('got salt and verifier');

    // store session
    const session = srpSessionSchema.parse({
      sessionId: email,
      salt,
      verifier,
      b,
      B,
    });
    // use email as session id to only have one session id per user
    await this.db.srpSessionRepository.storeSRPAuthSession(email, session);

    console.log('session stored');

    return {
      salt,
      B,
    };
  }

  /**
   * Get the user's SRP auth session
   * @param email - The user's email
   * @returns The SRP auth session if it exists
   */
  public async getAuthSession(email: Email): Promise<SRPSession | null> {
    return await this.db.srpSessionRepository.getSRPAuthSession(email);
  }

  ///**
  // * Registers a user with our system
  // * @param data - The user's information
  // * @returns The user that was created and their MFA formatted key
  // */
  //public async registerUser(
  //  data: CreateUserData,
  //): Promise<{ user: UserWithId; mfaFormattedKey: MFAFormattedKey }> {
  //  const userId = await this.db.userRepository.createUser(data, formattedKey);
  //
  //  return {
  //    user: await this.db.userRepository.getUserById(userId),
  //    mfaFormattedKey: formattedKey,
  //  };
  //}

  /**
   * Check if a user with the provided email exists
   * @param email - The email to check
   * @returns true if the email is registered, false otherwise
   */
  public async userExistsEmail(email: Email): Promise<boolean> {
    return await this.db.userRepository.userExistsEmail(email);
  }

  /**
   * Check if a user witht he provided id exists
   * @param userId - The id to check
   * @returns true if the user exists, false otherwise
   */
  public async userExistsId(userId: string): Promise<boolean> {
    return await this.db.userRepository.userExists(userId);
  }

  /**
   * Verify an MFA Code and mark the user's mfa as correctly setup/confirmed
   * @param userId - The id of the user
   * @param code - the MFA code to verify
   * @throws An error if the user does not exist
   * @throws An error if the user already confirmed MFA
   * @throws An IncorrectMFATokenError if the code is incorrect
   */
  public async confirmUserMFA(userId: string, code: MFACode) {
    const userMFA = await this.db.userRepository.getUserMFA(userId);
    if (userMFA.confirmed) {
      throw new MFAError(MFAErrorType.MFA_ALREADY_CONFIRMED);
    }
    const ms = new MFAService();
    if (ms.verifyCode(userMFA.formattedKey, code)) {
      // correct, mark mfa as confirmed
      await this.db.userRepository.confirmUserMFA(userId);
    } else {
      throw new MFAError(MFAErrorType.INCORRECT_CODE);
    }
  }

  /**
   * Get a user by their id
   * @param userId - The user's id
   * @returns The user
   */
  public async getUserById(userId: ObjectIdOrString): Promise<UserWithId> {
    return await this.db.userRepository.getUserById(userId);
  }

  //public async login(data: LoginData): Promise<{ user: UserWithId; mfa: MFA }> {
  public async login(data: {
    email: string;
    salt: string;
    verifier: bigint;
    A: bigint;
    b: bigint;
    B: bigint;
    Mc: bigint;
  }) {
    const serverProof = SRP.verifyClientProof(data);

    // method didn't throw, client proof correct

    const user = await this.db.userRepository.getUserDocByEmail(data.email);
    const mfa: MFA = {
      confirmed: user.mfaConfirmed,
      formattedKey: user.mfaFormattedKey,
    };

    return { user: userWithIdSchema.parse(user), mfa, Ms: serverProof };
  }

  /**
   * Verify the MFA code entered by the user is correct
   * @param userId - The id of the user
   * @param code - The MFA code the user entered
   * @returns true if correct, false otherwise
   * @throws An MFAError if the user has not confirmed setting up MFA
   */
  public async verifyMFA(
    userId: ObjectIdOrString,
    code: MFACode,
  ): Promise<boolean> {
    const mfa = await this.db.userRepository.getUserMFA(userId);
    if (!mfa.confirmed) {
      throw new MFAError(MFAErrorType.MFA_NOT_CONFIRMED);
    }
    const ms = new MFAService();
    const result = ms.verifyCode(mfa.formattedKey, code);
    return result;
  }
}

// TODO: implement the safeguards (checking for == 0, etc)

/** A class to handle the SRP protocol's cryptographic operations */
class SRP {
  public static generateServerKeys(): { b: bigint; B: bigint } {
    // TODO: add k * v
    const N = BigInt('0x' + SRP_N_HEX);
    console.log('got N');

    const g = BigInt(SRP_GENERATOR);
    console.log('got g');

    const b = BigInt(`0x${crypto.randomBytes(32).toString('hex')}`);
    console.log('got b');

    //const B = g ** b % N;
    const B = bigIntModPow(g, b, N);
    console.log('got B');

    return { b, B };
  }

  // TODO: implement k
  /**
   * Verify the client SRP proof
   * @param email - The user's email
   * @param salt - The user's salt
   * @param verifier - The user's verifier
   * @param A - The client's public key
   * @param b - The server's private key
   * @param B - The server's public key
   * @param Mc - The client's proof
   * @returns The server's proof for the client to verify
   * @throws an InvalidPasswordError if the client proof is incorrect
   */
  public static verifyClientProof(data: {
    email: string;
    salt: string;
    verifier: bigint;
    A: bigint;
    b: bigint;
    B: bigint;
    Mc: bigint;
  }): string {
    // calculate u = H(A | B)
    const u = BigInt(
      `0x${this.hash(data.A.toString(16) + data.B.toString(16)).digest('hex')}`,
    );

    // calculate shared secret S = (A * v^u) ^ b % N
    const g = BigInt(SRP_GENERATOR);
    const N = BigInt(`0x${SRP_N_HEX}`);
    const S = (data.A * data.verifier ** u) ** data.b % N;
    //const S = bigIntModPow(A * bigIntModPow(verifier, u, N), b, N);

    // calculate session key K = H(S)
    const K = this.hash(S).digest('hex');

    // calculate server proof Ms = H(H(N) xor H(g) | H(email) | salt | A | B | K)
    const HN = createHash('sha256').update(N.toString(16)).digest();
    const Hg = createHash('sha256').update(g.toString(16)).digest();
    const He = this.hash(data.email).digest('hex');

    const expectedMc = this.hash(
      this.xorBuffers(HN, Hg).toString('hex') +
        He +
        data.salt +
        data.A.toString(16) +
        data.B.toString(16) +
        K,
    ).digest('hex');

    if (BigInt(expectedMc) !== data.Mc) {
      throw new IncorrectPasswordError();
    }

    // generate server proof Ms = H(A | Mc | K)
    const Ms = this.hash(data.A.toString(16) + data.Mc.toString(16) + K).digest(
      'hex',
    );
    return Ms;
  }

  protected static hash(val: bigint | string): Hash {
    if (typeof val === 'bigint') {
      return createHash('sha256').update(val.toString(16));
    } else {
      return createHash('sha256').update(val);
    }
  }

  protected static xorBuffers(a: Buffer, b: Buffer): Buffer {
    const result = Buffer.alloc(Math.max(a.length, b.length));
    for (let i = 0; i < result.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return result;
  }
}

// TEMP: class to simulate client side till srp implemented on the client side
// TODO: remove this
class ClientSRP {
  public static generateSalt(): string {
    return crypto.randomBytes(16).toString('hex');
  }

  public static generateVerifier(salt: string, password: string): string {
    // Calculate x = H(salt | H(P))

    // First, calculate H(P)
    const innerHash = crypto.createHash('sha256');
    innerHash.update(password);
    const innerHashResult = innerHash.digest();

    // Then calculate H(salt | H(P))
    const outerHash = crypto.createHash('sha256');
    outerHash.update(Buffer.from(salt, 'hex'));
    outerHash.update(innerHashResult);
    const x = BigInt('0x' + outerHash.digest('hex'));

    // Calculate v = g^x mod N
    const N = BigInt('0x' + SRP_N_HEX);
    const g = BigInt(SRP_GENERATOR);
    const v = g ** x % N;

    // Return the verifier as a hex string
    return v.toString(16);
  }

  public static generateClientKeys(): { a: bigint; A: bigint } {
    const N = BigInt('0x' + SRP_N_HEX);
    const g = BigInt(SRP_GENERATOR);
    const a = BigInt(crypto.randomBytes(32).toString('hex'));
    const A = g ** a % N;
    return { a, A };
  }

  // TODO: implement k
  public static calculateProof(
    email: string,
    password: string,
    salt: string,
    B: bigint,
    a: bigint,
    A: bigint,
  ) {
    // calculate x = H(salt | H(password))
    const hashPassword = this.hash(password);
    const x = BigInt(this.hash(salt + hashPassword));

    // calculate u = H(A | B)
    const u = BigInt(this.hash(A.toString(16) + B.toString(16)));

    // calculate shared secret S = (B - k * g^x) ^ (a + u * x) % N
    const g = BigInt(SRP_GENERATOR);
    const N = BigInt('0x' + SRP_N_HEX);
    const S = (B - g ** x) ** (a + u * x) % N;

    // calculate session key K = H(S)
    const K = this.hash(S);

    // calculate client proof Mc = H(H(N) xor H(g) | H(email) | salt | A | B | K)
    const HN = createHash('sha256').update(N.toString(16)).digest();
    const Hg = createHash('sha256').update(g.toString(16)).digest();
    const He = this.hash(email);

    const Mc = this.hash(
      this.xorBuffers(HN, Hg).toString('hex') +
        He +
        salt +
        A.toString(16) +
        B.toString(16) +
        K,
    );

    return {
      A,
      Mc: BigInt(Mc),
    };
  }

  protected static hash(val: bigint | string): string {
    if (typeof val === 'bigint') {
      return createHash('sha256').update(val.toString(16)).digest('hex');
    } else {
      return createHash('sha256').update(val).digest('hex');
    }
  }

  protected static xorBuffers(a: Buffer, b: Buffer): Buffer {
    const result = Buffer.alloc(Math.max(a.length, b.length));
    for (let i = 0; i < result.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return result;
  }
}

const SRP_N_HEX =
  `AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294 3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB D5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF74 7359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A 436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D 5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73 03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6 94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F 9E4AFF73`
    .trim()
    .replace(/[\s\r\n]+/g, '');
const SRP_GENERATOR = 2;
